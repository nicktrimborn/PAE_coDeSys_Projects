

(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/FBs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_Lift
VAR_INPUT
	bReset			 : BOOL;	(*Reset Request*)
	bEnable			 : BOOL;
	I_LimitUp 			 : BOOL;
	I_LimitLow 	        : BOOL;
	I_WaitingBallMetal : BOOL;

	(* ColourSensor *)
	I_SenColourYellow		:BOOL;	(*Colour sensor In1 - Yellow*)
	I_SenColourBlue		:BOOL;	(*Colour sensor In2 - Blue*)
	I_SenColourGreen		:BOOL;	(*Colour sensor In3 - Green*)
	I_SenColourRed		:BOOL;	(*Colour sensor In4 - Red*)

	(*SMEMA Handshake Inputs*)
	hiRdyToReceive_FromDS	: BOOL;
	hiBallAvail_FromUS			: BOOL;
END_VAR
VAR_OUTPUT
	bStopOK		: BOOL;
	bBallLoaded	: BOOL;
	bCurBallMetal	: BOOL;
	bCurrentBall 	: E_BallColour := NoColour;

	O_Ejector		:BOOL;

	(*SMEMA Handshake Outputs*)
	hoBallAvail_ToDS				: BOOL;
	hoReadyToRecieve_ToUS	: BOOL;
END_VAR
VAR
	bBallRequested : BOOL := FALSE;
	fbTransferBall	:FB_TransferBall;

	fbDelay		: FB_Wait;
	tonMoveDelay	: TON;
	tonSensorDelay	: TON;
	tTransferDelay: TIME := T#4s;
	tMoveDelay	: TIME := T#4s;
	tSensorDelay	: TIME := T#2s;
	bLocalReset	: BOOL;	(*Performs local reset*)
	SFCReset 	: BOOL;	(*Resets the execution of SFC to init once this SFCFlag is set true *)
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bLocalReset	:= FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitForSFCReset,MainLoop,UpdateIOs):= 
NOT bReset


END_TRANSITION
STEP WaitForSFCReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP MainLoop:
hoBallAvail_ToDS			  := FALSE;
hoReadyToRecieve_ToUS := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM MainLoop TO NiceStop:= 
bEnable


END_TRANSITION
STEP NiceStop:
bStopOK	  	:= TRUE;
bCurrentBall	:= NoColour;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM NiceStop TO WaitForBall:= 
bEnable AND NOT bBallLoaded


END_TRANSITION
STEP WaitForBall:
bBallLoaded := FALSE;
hoReadyToRecieve_ToUS := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM WaitForBall TO RequestBall:= 
hiBallAvail_FromUS AND NOT bBallLoaded


END_TRANSITION
STEP RequestBall:

INITIAL_STEP Init_fetchfball:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init_fetchfball TO CheckBallMetal:= 
NOT bBallRequested


END_TRANSITION
STEP CheckBallMetal:
bCurBallMetal	 := I_WaitingBallMetal;
fbDelay(IN_TIME:=T#2s);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM CheckBallMetal TO Request:= 
fbDelay.OK


END_TRANSITION
STEP Request:
hoReadyToRecieve_ToUS := TRUE;
bBallRequested := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Request TO Init_fetchfball:= 
bBallRequested


END_TRANSITION


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION	
bStopOK := FALSE;
END_ACTION

EXIT_ACTION	
bBallRequested := FALSE;
END_ACTION

TRANSITION FROM RequestBall TO Transferring:= 
bBallRequested


END_TRANSITION
STEP Transferring:
fbDelay(IN_TIME:=tTransferDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Transferring TO Load_Handshake:= 
fbDelay.OK


END_TRANSITION
STEP Load_Handshake:
hoReadyToRecieve_ToUS := FALSE;


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Load_Handshake TO TransferComplete:= 
NOT hiBallAvail_FromUS


END_TRANSITION
STEP TransferComplete:
bBallLoaded := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM TransferComplete TO Wait:= 
bBallLoaded


END_TRANSITION
STEP Wait:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Wait TO MoveToColorSen:= 
bBallLoaded AND NOT bCurBallMetal


END_TRANSITION
STEP MoveToColorSen:
PRG_ToColourSensor2(bExecute:=TRUE , bDone=> );

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
PRG_ToColourSensor2( bExecute:=FALSE);
END_ACTION

TRANSITION FROM MoveToColorSen TO WaitForSensor:= 
PRG_ToColourSensor2.bDone


END_TRANSITION
STEP WaitForSensor:
tonSensorDelay(IN:=TRUE , PT:= tSensorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonSensorDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM WaitForSensor TO Classify:= 
tonSensorDelay.Q


END_TRANSITION
STEP Classify:
tonSensorDelay(IN:=TRUE , PT:= tSensorDelay);
IF I_SenColourYellow THEN
	bCurrentBall := Yellow;
ELSIF  I_SenColourBlue THEN
	bCurrentBall := Blue;
ELSIF  I_SenColourRed THEN
	bCurrentBall := Red;
ELSE
	bCurrentBall := NoColour;
END_IF


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonSensorDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Classify TO Transfer:= 
tonSensorDelay.Q


END_TRANSITION
STEP Transfer:
fbTransferBall(bExecute:= TRUE , bBallToTransfer:= bCurrentBall, bDone=> );

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbTransferBall(bExecute:= FALSE);
END_ACTION

TRANSITION FROM Transfer TO Wait_Transfer:= 
fbTransferBall.bDone


END_TRANSITION
STEP Wait_Transfer:
fbDelay(IN_TIME:=tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Wait_Transfer TO DeliveredWood:= 
fbDelay.OK


END_TRANSITION
STEP DeliveredWood:
bBallLoaded := FALSE;
bCurrentBall := NoColour;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM DeliveredWood TO NiceStop:= 
NOT bBallLoaded


END_TRANSITION
TRANSITION FROM Wait TO DeliverToBotTube:= 
bBallLoaded AND bCurBallMetal


END_TRANSITION
STEP DeliverToBotTube:
PRG_DeliverToLow2(bExecute:=TRUE ,  bDone=> );

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM DeliverToBotTube TO DeliveredMetal:= 
PRG_DeliverToLow2.bDone


END_TRANSITION
STEP DeliveredMetal:
bBallLoaded := FALSE;


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
ENTRY_ACTION	
bBallLoaded := FALSE;
PRG_DeliverToLow(bReset:=FALSE , bExecute:=FALSE ,  bDone=> );
END_ACTION

EXIT_ACTION	
PRG_DeliverToLow(bReset:=FALSE , bExecute:=FALSE ,  bDone=> );
END_ACTION

TRANSITION FROM DeliveredMetal TO NiceStop:= 
NOT bBallLoaded


END_TRANSITION
STEP UpdateIOs:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM UpdateIOs TO UpdateIOs:= 
FALSE


END_TRANSITION
TRANSITION FROM (WaitForSFCReset) TO SFCResetStep:= 
bLocalReset OR bReset


END_TRANSITION
STEP SFCResetStep:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM SFCResetStep TO Init:= 
FALSE


END_TRANSITION

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/FBs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_Sorter
VAR_INPUT
	bReset			: BOOL;	(*Reset Request*)
	bEnable			: BOOL;
	I_SensorOpt		: BOOL;
	I_SensorInd		: BOOL;
	I_SorterLiftUp		: BOOL;
	I_SorterLiftDown	: BOOL;

	(*SMEMA Handshake Inputs*)
	hiRdyToReceive_FromDS	: BOOL;
	hiBallAvail_FromUS			: BOOL;
END_VAR
VAR_OUTPUT
	bStopOK			: BOOL;
	bBallLoaded		: BOOL;
	bCurBallMetal		: BOOL;
	O_SorterGate		: BOOL;
	O_SorterLift		: BOOL;

	(*SMEMA Handshake Outputs*)
	hoBallAvail_ToDS				: BOOL;
	hoReadyToRecieve_ToUS	: BOOL;
END_VAR
VAR
	tTransferDelay: TIME := T#4s;
	tMoveDelay	: TIME := T#2s;
	fbDelay		: FB_Wait;
	bLocalReset	: BOOL;	(*Performs local reset*)
	SFCReset 	: BOOL;	(*Resets the execution of SFC to init once this SFCFlag is set true *)
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bLocalReset	:= FALSE;
bStopOK := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitForSFCReset,MainLoop,UpdateIOs):= 
NOT bReset


END_TRANSITION
STEP WaitForSFCReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP MainLoop:
hoBallAvail_ToDS			  := FALSE;
hoReadyToRecieve_ToUS := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM MainLoop TO NiceStop:= 
bEnable


END_TRANSITION
STEP NiceStop:
bBallLoaded 				  := FALSE;
bStopOK					  := TRUE;
hoBallAvail_ToDS			  := FALSE;
hoReadyToRecieve_ToUS := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM NiceStop TO WaitForBall:= 
bEnable AND hiRdyToReceive_FromDS


END_TRANSITION
STEP WaitForBall:
fbDelay(IN_TIME:=tMoveDelay);
(* Move Lift Down *)
O_SorterLift := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM WaitForBall TO LiftBall:= 
I_SensorOpt AND fbDelay.OK


END_TRANSITION
TRANSITION FROM WaitForBall TO NiceStop:= 
NOT bEnable


END_TRANSITION
STEP LiftBall:

INITIAL_STEP Init_Load:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init_Load TO Lift:= 
NOT bBallLoaded


END_TRANSITION
STEP Lift:
O_SorterLift := TRUE;
fbDelay(IN_TIME:=tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION WaitForLifting FROM Lift TO BallRollToGate:= 
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
''
_END_COMMENT
_OPERATOR
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
I_SorterLiftUp
_OPERAND
_EXPRESSION
_POSITIV
 fbDelay.OK
_OPERAND
_EXPRESSION
_POSITIV
NOT I_SensorOpt
_EXPRESSION
_POSITIV
AND


END_TRANSITION
STEP BallRollToGate:
fbDelay(IN_TIME:=tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM BallRollToGate TO Classify:= 
fbDelay.OK


END_TRANSITION
STEP Classify:
fbDelay(IN_TIME:=tMoveDelay);
IF I_SensorInd THEN
	bCurBallMetal := FALSE;
ELSE
	bCurBallMetal := TRUE;
END_IF


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Classify TO BallLoaded:= 
fbdelay.OK


END_TRANSITION
STEP BallLoaded:
bBallLoaded := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM BallLoaded TO Init_Load:= 
bBallLoaded


END_TRANSITION


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM LiftBall TO BallAvalible:= 
bBallLoaded


END_TRANSITION
STEP BallAvalible:
hoBallAvail_ToDS := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM BallAvalible TO BallRequested:= 
hiRdyToReceive_FromDS


END_TRANSITION
STEP BallRequested:
fbDelay(IN_TIME:=tMoveDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM BallRequested TO Transfering:= 
fbDelay.OK


END_TRANSITION
STEP Transfering:
O_SorterGate := TRUE;
fbDelay(IN_TIME:=tTransferDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
O_SorterGate := FALSE;
END_ACTION

TRANSITION FROM Transfering TO Unload_Handshake:= 
fbDelay.OK


END_TRANSITION
STEP Unload_Handshake:
hoBallAvail_ToDS := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Unload_Handshake TO TransferComplete:= 
NOT hiRdyToReceive_FromDS


END_TRANSITION
STEP TransferComplete:
bBallLoaded := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM TransferComplete TO NiceStop:= 
TRUE


END_TRANSITION
STEP UpdateIOs:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM UpdateIOs TO UpdateIOs:= 
FALSE


END_TRANSITION
TRANSITION FROM (WaitForSFCReset) TO SFCResetStep:= 
bLocalReset OR bReset


END_TRANSITION
STEP SFCResetStep:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM SFCResetStep TO Init:= 
FALSE


END_TRANSITION

END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/FBs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
FUNCTION_BLOCK FB_TransferBall
VAR_INPUT
	bExecute			: BOOL;	(*enable and run*)
	bBallToTransfer 	: E_BallColour;
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
	bActDone		: BOOL := FALSE;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#2s;
END_VAR
(* @END_DECLARATION := '0' *)
IF bExecute THEN
	CASE bBallToTransfer OF
		Yellow:
			PRG_DeliverToUp2( bExecute:= TRUE , bDone=> );
				bDone	:= FALSE;
				IF PRG_DeliverToUp2.bDone THEN
					PRG_DeliverToUp2(bExecute:=FALSE);
					bDone	:= TRUE;
				END_IF
		Blue:
			PRG_DeliverToMid2( bExecute:= TRUE, bDone=> );
				bDone	:= FALSE;
				IF PRG_DeliverToMid2.bDone THEN
					PRG_DeliverToMid2(bExecute:=FALSE);
					bDone	:= TRUE;
				END_IF
		Red:
			PRG_DeliverToGarbage2( bExecute:= TRUE, bDone=> );
				bDone	:= FALSE;
				IF PRG_DeliverToGarbage2.bDone THEN
					PRG_DeliverToGarbage2( bExecute:=FALSE);
					bDone	:= TRUE;
				END_IF
	ELSE
		PRG_DeliverToMid2(bExecute:=FALSE);
		PRG_DeliverToUp2(bExecute:=FALSE);
		PRG_DeliverToGarbage2( bExecute:=FALSE);
		bDone	:= FALSE;
	END_CASE
ELSE
	bDone := FALSE;
END_IF




END_FUNCTION_BLOCK


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToGarbage
VAR_INPUT
	bReset		: BOOL;	(*Reset program*)
	bExecute		: BOOL;	(*enable and run*)
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	SFCReset		: BOOL;

	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#2s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitReset,Process):= 
NOT bReset


END_TRANSITION
STEP WaitReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Process:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Process TO MoveToGarbage:= 
bExecute


END_TRANSITION
STEP MoveToGarbage:
bDone := FALSE;

fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_GARBAGE);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToGarbage TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Done TO Process:= 
NOT bExecute


END_TRANSITION
TRANSITION FROM (WaitReset) TO Reseting:= 
bReset


END_TRANSITION
STEP Reseting:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Reseting TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToGarbage2
VAR_INPUT
	bExecute: BOOL;
END_VAR
VAR_INPUT
	bDone: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#3s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Init TO MoveToGarbage:= 
bExecute


END_TRANSITION
STEP MoveToGarbage:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_GARBAGE);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToGarbage TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Done TO Init:= 
NOT bExecute


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToLow
VAR_INPUT
	bReset		: BOOL;	(*Reset program*)
	bExecute		: BOOL;	(*enable and run*)

END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	SFCReset		: BOOL;

	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitReset,Process):= 
NOT bReset


END_TRANSITION
STEP WaitReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Process:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Process TO MoveToLow:= 
bExecute


END_TRANSITION
STEP MoveToLow:
bDone := FALSE;

fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_PIPE_LOW);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToLow TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Done TO Process:= 
NOT bExecute


END_TRANSITION
TRANSITION FROM (WaitReset) TO Reseting:= 
bReset


END_TRANSITION
STEP Reseting:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Reseting TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToLow2
VAR_INPUT
	bExecute: BOOL;
END_VAR
VAR_INPUT
	bDone: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Init TO MoveToLow:= 
bExecute


END_TRANSITION
STEP MoveToLow:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_PIPE_LOW);



END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToLow TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Done TO Init:= 
NOT bExecute


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToMid
VAR_INPUT
	bReset		: BOOL;	(*Reset program*)
	bExecute		: BOOL;	(*enable and run*)
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	SFCReset		: BOOL;

	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#2s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitReset,Process):= 
NOT bReset


END_TRANSITION
STEP WaitReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Process:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Process TO MoveToMid:= 
bExecute


END_TRANSITION
STEP MoveToMid:
bDone := FALSE;

fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:=GPOS_PIPE_MID);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToMid TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Done TO Process:= 
NOT bExecute


END_TRANSITION
TRANSITION FROM (WaitReset) TO Reseting:= 
bReset


END_TRANSITION
STEP Reseting:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Reseting TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToMid2
VAR_INPUT
	bExecute: BOOL;
END_VAR
VAR_INPUT
	bDone: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#3s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Init TO MoveToMid:= 
bExecute


END_TRANSITION
STEP MoveToMid:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_PIPE_MID);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToMid TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Done TO Init:= 
NOT bExecute


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToUp
VAR_INPUT
	bReset		: BOOL;	(*Reset program*)
	bExecute		: BOOL;	(*enable and run*)
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	SFCReset		: BOOL;

	tMoveDelay	: TIME := T#4s;
	tEjectorDelay	: TIME := T#2s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitReset,Process):= 
NOT bReset


END_TRANSITION
STEP WaitReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Process:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Process TO MoveToUP:= 
bExecute


END_TRANSITION
STEP MoveToUP:
bDone := FALSE;

fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_PIPE_UP);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToUP TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Done TO Process:= 
NOT bExecute


END_TRANSITION
TRANSITION FROM (WaitReset) TO Reseting:= 
bReset


END_TRANSITION
STEP Reseting:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Reseting TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_DeliverToUp2
VAR_INPUT
	bExecute: BOOL;
END_VAR
VAR_INPUT
	bDone: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#3s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Init TO MoveToUp:= 
bExecute


END_TRANSITION
STEP MoveToUp:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_PIPE_UP);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToUp TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Eject:= 
tonMoveDelay.Q


END_TRANSITION
STEP Eject:
OEjector := TRUE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Eject TO ResetEjector:= 
tonEjectDelay.Q


END_TRANSITION
STEP ResetEjector:
OEjector := FALSE;
tonEjectDelay(IN:=TRUE , PT:= tEjectorDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonEjectDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ResetEjector TO ReturnToLoading:= 
tonEjectDelay.Q


END_TRANSITION
STEP ReturnToLoading:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_LOADING);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM ReturnToLoading TO Wait_Return:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Return:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Return TO Done:= 
 tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Done TO Init:= 
NOT bExecute


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_ToColourSensor
VAR_INPUT
	bReset		: BOOL;	(*Reset program*)
	bExecute		: BOOL;	(*enable and run*)
END_VAR
VAR_OUTPUT
	bDone			: BOOL;
END_VAR
VAR

	tonMoveDelay	: TON;
	SFCReset		: BOOL;
	tMoveDelay	: TIME := T#4s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
SFCReset := FALSE;
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitReset,Process):= 
NOT bReset


END_TRANSITION
STEP WaitReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Process:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Process TO MoveToColour:= 
bExecute


END_TRANSITION
STEP MoveToColour:
bDone := FALSE;

fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_COLOR_SEN);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

(*
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);
*)

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);

tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToColour TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Done:= 
tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Done TO Process:= 
NOT bExecute


END_TRANSITION
TRANSITION FROM (WaitReset) TO Reseting:= 
bReset


END_TRANSITION
STEP Reseting:
SFCReset := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Reseting TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Processes' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_ToColourSensor2
VAR_INPUT
	bExecute: BOOL;
END_VAR
VAR_INPUT
	bDone: BOOL;
END_VAR
VAR
	tonMoveDelay	: TON;
	tonEjectDelay	: TON;
	tMoveDelay	: TIME := T#3s;
	tEjectorDelay	: TIME := T#3s;
END_VAR
(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Init TO MoveToColour:= 
bExecute


END_TRANSITION
STEP MoveToColour:
fbDrive(
	bEnable:= TRUE,
	bStart:= TRUE,
	wTarget:= GPOS_COLOR_SEN);

tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive(
	bStart:= FALSE);
tonMoveDelay(IN:=FALSE);

END_ACTION

TRANSITION FROM MoveToColour TO Wait_Arrive:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP Wait_Arrive:
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM Wait_Arrive TO Done:= 
tonMoveDelay.Q


END_TRANSITION
STEP Done:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
bDone := FALSE;
END_ACTION

TRANSITION FROM Done TO Init:= 
NOT bExecute


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_AutoSort
VAR_INPUT
	bExecute	: BOOL;
	bReset	: BOOL := FALSE;
END_VAR
VAR_OUTPUT
	bDone		: BOOL;		(*Program operations done*)
	bStopOk    : BOOL;
END_VAR
VAR
	fbSorter	: FB_Sorter;
	fbLift		: FB_Lift;
	bBatchComplete  : BOOL := FALSE;
END_VAR
(* @END_DECLARATION := '0' *)
actUpdateIO;
actCheckAllOkStop;

CASE fbStateModel.eState OF
	eSt_Idle:
		fbStateModel.bComplete  := FALSE;
		fbStateModel.bSC 		:= TRUE;
	eSt_Resetting:
		fbStateModel.bSC := TRUE;
	eSt_Stopping:
		fbStateModel.bStop := FALSE;

		IF  bStopOk THEN
			fbStateModel.bSC := TRUE;
		END_IF
	eSt_Execute:
		fbSorter (bEnable :=  TRUE , bReset := FALSE);
		fbLift(bEnable :=  TRUE , bReset := FALSE);
		IF bBatchComplete  THEN
			fbStateModel.bComplete := TRUE;
		END_IF

	eSt_Completing:
		fbStateModel.bComplete := FALSE;
		IF bStopOK THEN
			fbStateModel.bSC := TRUE;
		END_IF

	eSt_Unsuspending:
		fbStateModel.bSC := TRUE;

	eSt_Suspending:
		fbStateModel.bSuspend := FALSE;
		fbStateModel.bSC := TRUE;

END_CASE
END_PROGRAM
ACTION	actCheckAllOKStop:
IF fbSorter.bStopOK AND  fbLift.bStopOK THEN
	bStopOK := TRUE;
ELSE
	bStopOK := FALSE;
END_IF
END_ACTION

ACTION	actUpdateIO:
fbSorter (
	bReset:= ,
	bEnable:= bExecute,
	I_SensorOpt:= ISensorOpt ,
	I_SensorInd:= ISensorInd,
	I_SorterLiftUp:= ISorterLiftUp ,
	I_SorterLiftDown:= ISorterLiftDown,
	hiRdyToReceive_FromDS:= fbLift.hoReadyToRecieve_ToUS ,
	hiBallAvail_FromUS:= ,
	bStopOK=> ,
	bBallLoaded=> ,
	bCurBallMetal=> ,
	O_SorterGate=> OSorterGate ,
	O_SorterLift=> OSorterLift ,
	hoBallAvail_ToDS=> ,
	hoReadyToRecieve_ToUS=> );

fbLift (
	bReset:= ,
	bEnable:= bExecute,
	I_LimitUp:= ILimitUp  ,
	I_LimitLow:= ILimitLow,
	I_WaitingBallMetal:= fbSorter.bCurBallMetal  ,
	I_SenColourYellow:= ISenColourYellow ,
	I_SenColourBlue:= ISenColourBlue ,
	I_SenColourGreen:= ISenColourGreen,
	I_SenColourRed:= ISenColourRed ,
	hiRdyToReceive_FromDS:= ,
	hiBallAvail_FromUS:= fbSorter.hoBallAvail_ToDS ,
	bStopOK=> ,
	bBallLoaded=> , 
	bCurBallMetal=> , 
	O_Ejector=> OEjector ,
	hoBallAvail_ToDS=> , 
	hoReadyToRecieve_ToUS=> );
END_ACTION





(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '\/Programs' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM PRG_Initialisation
(*Template program for system initialisation*)
VAR_INPUT
	bReset	: BOOL := FALSE;	(*Reseting the SFC*)
	bExecute	: BOOL;			(*Executes PRG*)
END_VAR
VAR_OUTPUT
	bDone		: BOOL;		(*Program operations done*)
END_VAR
VAR
(* -------------INTERNAL-------------------*)
	tonMoveDelay		: TON;
	tMoveDelay		: TIME := T#1s;
	bInitDone			: BOOL:=FALSE;	(*Initialisation done*)
	bGatesClosed	: BOOL:=FALSE;	(*Initialisation done*)
	bActuRetracted	: BOOL:=FALSE;
	bDriveAtLoading	: BOOL:=FALSE;

(*System variables. See SFC-flags: http://infosys.beckhoff.com/content/1033/tcplccontrol/html/tcplcctrl_editorsfc.htm?id=24319#SFC-Flags*)
	SFCReset		: BOOL := FALSE;	(*For reseting the SFC*)
END_VAR

(* @END_DECLARATION := '0' *)

INITIAL_STEP Init:
(*Clear Reset SFC*)
SFCReset:= FALSE;
bDone := FALSE;


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Init TO (WaitForReset,InitMachine,IO_Update):= 
NOT bReset


END_TRANSITION
STEP WaitForReset:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM WaitForReset TO ResetSFC:= 
bReset


END_TRANSITION
STEP ResetSFC:
(*Reset SFC*)
SFCReset:=TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP InitMachine:
(*Do some actions...

Sulje kaikki portit ... JA tarkista Steppiä seuraavassa transitioehdossa, että kaikki portit ovat kiinni
Close all gates.... and check in following transition that ALL gates are closed*)

;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := 'Implement here your sequence' *)
TRANSITION FROM InitMachine TO StartInit:= 
bExecute


END_TRANSITION
STEP StartInit:
bDone := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM StartInit TO (Gates,Actuators,Lift):= 
TRUE


END_TRANSITION
STEP Gates:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Gates TO CloseGates:= 
TRUE


END_TRANSITION
STEP CloseGates:
OGateUp		:= FALSE;
OGateMid		:= FALSE;
OGateLow		:= FALSE;
OSorterGate	:= FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION CheckGates FROM CloseGates TO GatesClosed:= 
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
''
_END_COMMENT
_OPERATOR
_BOX_EXPR : 4
_OPERAND
_EXPRESSION
_POSITIV
IGateClosedUp
_OPERAND
_EXPRESSION
_POSITIV
IGateClosedMid
_OPERAND
_EXPRESSION
_POSITIV
IGateClosedLow
_OPERAND
_EXPRESSION
_POSITIV
ISorterGateClosed
_EXPRESSION
_POSITIV
AND


END_TRANSITION
STEP GatesClosed:
bGatesClosed := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Actuators:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Actuators TO ActuRetract:= 
TRUE


END_TRANSITION
STEP ActuRetract:
OSorterLift	 := FALSE;
OEjector	 := FALSE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION checkActuator FROM ActuRetract TO ActuRetracted:= 
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
''
_END_COMMENT
_OPERATOR
_BOX_EXPR : 2
_OPERAND
_EXPRESSION
_POSITIV
ISorterLiftDown
_OPERAND
_EXPRESSION
_POSITIV
NOT OEjector
_EXPRESSION
_POSITIV
AND


END_TRANSITION
STEP ActuRetracted:
bActuRetracted := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
STEP Lift:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM Lift TO HomeLift:= 
TRUE


END_TRANSITION
STEP HomeLift:
fbDrive.bStart := TRUE;
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive.bStart:= FALSE;
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM HomeLift TO MoveToLoading:= 
fbDrive.bHomingDone AND tonMoveDelay.Q


END_TRANSITION
STEP MoveToLoading:
fbDrive.wTarget := GPOS_LOADING;
fbDrive.bStart:= TRUE;
tonMoveDelay(IN:=TRUE , PT:= tMoveDelay);

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
EXIT_ACTION	
fbDrive.bStart:= FALSE;
tonMoveDelay(IN:=FALSE);
END_ACTION

TRANSITION FROM MoveToLoading TO DriveInLoadingPos:= 
fbDrive.bMoveDone AND tonMoveDelay.Q


END_TRANSITION
STEP DriveInLoadingPos:
bDriveAtLoading := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION checkAllComplete FROM (GatesClosed,ActuRetracted,DriveInLoadingPos) TO InitMachineDone:= 
_FBD_BODY
_NETWORKS : 1
_NETWORK

_COMMENT
''
_END_COMMENT
_OPERATOR
_BOX_EXPR : 3
_OPERAND
_EXPRESSION
_POSITIV
bGatesClosed
_OPERAND
_EXPRESSION
_POSITIV
bActuRetracted
_OPERAND
_EXPRESSION
_POSITIV
bDriveAtLoading
_EXPRESSION
_POSITIV
AND


END_TRANSITION
STEP InitMachineDone:
bDone := TRUE;

END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM InitMachineDone TO InitMachine:= 
NOT bExecute


END_TRANSITION
STEP IO_Update:


END_STEP
(* @SFCMAXTIME := '' *)
(* @SFCMINTIME := '' *)
(* @SFCCOMMENT := '' *)
TRANSITION FROM IO_Update TO IO_Update:= 
TRUE


END_TRANSITION
TRANSITION FROM (ResetSFC) TO Init:= 
FALSE


END_TRANSITION

END_PROGRAM


(* @NESTEDCOMMENTS := 'No' *)
(* @PATH := '' *)
(* @OBJECTFLAGS := '0, 8' *)
(* @SYMFILEFLAGS := '2048' *)
PROGRAM MAIN
(*Main program for application. Uses PackML state model to control the execution of the application*)
VAR
	tonStarting				: TON;
	rsEmergencyClear	: RS;	(*RS - flip-flop for Emergency clear info*)
END_VAR
(* @END_DECLARATION := '0' *)
(* ****** Section 1: Initialisations and default values. Initial conditions for variables on every PLC cycle*)
(*Default values*)
fbStateModel.bSC := FALSE;
(*System resets*)

(* ****** Section 2: Actions in your program without considering the Control Mode. I.e. actions are performed same way indenpendent on
current Control Mode selection.*)
(*Mode independent state actions. Change / Add / Remove states according your need*)
CASE fbStateModel.eState OF
eSt_Aborting:
	(* One can make specific actions in case of specific Mode-State combination.
	   One can also consider to call a specific program when in specific Mode-State combination*)
	actAborting;
	fbStateModel.bSC := TRUE;		(*MODIFY*)
eSt_Clearing:
	fbStateModel.bSC := TRUE;		(*MODIFY*)
eSt_Resetting:
	fbStateModel.bSC := TRUE;
eSt_Holding:
	fbStateModel.bSC := TRUE;		(*MODIFY*)
eSt_UnHolding:
	fbStateModel.bSC := TRUE;		(*MODIFY*)
eSt_Suspending:
	fbStateModel.bSC := TRUE;		(*MODIFY*)
eSt_Unsuspending:
	fbStateModel.bSC := TRUE;		(*MODIFY*)
END_CASE;

(* ****** Section 3: Actions in your program which are Control Mode specific. Two nested case structures where outer one selects the
control mode and inner the PackML state. In order to avoid conflicts, it would be better to process each PackML state either in Section 2 
or Section 3, but not in both. *)
(*Execution mode related state actions. Change / Add / Remove mode and states according your need*)
CASE fbStateModel.eMode OF
(*MODE: MANUAL*)
eMode_Manual:
	(* ****** Section 3.1: PackML state based processing actions when Control Mode is Manual.*)
	CASE fbStateModel.eState OF
	eSt_Starting:
		IF IPressureApplied THEN
			fbStateModel.bSC := TRUE;			(*MODIFY*)
		END_IF
	eSt_Stopping:
		fbStateModel.bSC := TRUE;			(*MODIFY*)
	END_CASE;

(*MODE: AUTOMATIC*)
eMode_Automatic:
	(* ****** Section 3.2: PackML state based processing actions when Control Mode is Automatic.*)
	CASE fbStateModel.eState OF
	eSt_Idle:
		tonStarting(IN:=FALSE , PT:= , Q=> , ET=> );	(*MODIFY*)
	eSt_Starting:
		(* tonStarting(IN:=TRUE , PT:=T#2s , Q=> , ET=> );
		fbStateModel.bSC := tonStarting.Q; *)
		IF IPressureApplied THEN
			bDriveEnabled := TRUE;
			PRG_Initialisation(bReset:= , bExecute:= TRUE , bDone=> );
		END_IF

		IF PRG_Initialisation.bDone THEN
			PRG_Initialisation(bReset:= , bExecute:= FALSE , bDone=> );
			fbStateModel.bSC := TRUE;
		END_IF
	eSt_Completing:
		fbStateModel.bSC := TRUE;					(*MODIFY*)
	eSt_Completed:
		;
	END_CASE;

(* ****** Section 4: Grouping PackML states for calling Programs or FB instances.
This is to avoid repetition inside above case structure in Section 3. With IF clause setting lower (and upper) state limits we can filter out the states when we want to call 
specific programs. The order of states is defined in Tab:Data types > E_PackMLState. eSt_Aborting is lowest and eSt_Completed is highest.
Here we filter calling programs, only when we are in higher states than Stopped. 
This can be pulled out as completely separated section, like in PackML_StateModel_v2-2.pro project. There is inside IF again CASE which process each Control Mode separately.*)
(*Execution part. Making calls for program if we are on states above Stopped*)
	(*If we are between specific states, make some action or program call*)
	IF  (fbStateModel.eState>eSt_Starting) AND (fbStateModel.eState<=eSt_Completing) THEN
		(*Make here the actions / calls Good place to start with is PRG_Sorting (PRG)*)
		PRG_AutoSort(bExecute:= TRUE , bReset:= , bDone=> , bStopOk=> );
	END_IF;

(*MODE: UNKNOWN*)
ELSE	(*Error*)
	; (*TODO*)
END_CASE;

(* ****** Section 5: Calling the fbStateModel instance.
Here the instance of state model is called and all triggering inputs are set, but bSC (State Completed), which you control in your programs. 
This is indication that your program has  finished certain stage.
- Pay attention where the instance fbStateModel is defined. Do you do it in global variables or e.g. here in PRG_MAIN? Important is to use the 
same instance in all places, so that machine state is unique and shared. Remember, if you have multiple definitions, the PRG_MAIN "hides" 
the global one, and might lead to problems elswhere, when you think you are using the same instance, but actually are not. 
- In case you are using the PackML visualisation (VC_PackMLStates), make sure you connect its placeholder to the very same PackML FB instance.
- The Mask for wIgnoreState is created as following. I use binary base for the value(2#). The lowest bit in the mask corresponds the eSt_Aborting
 in E_PackMLState. The next is eSt_Aborted, and so on. Specific state is ignored and jumped over when it is masked out i.e. ignored by having 1 
in that position. Note that implementation allows this only for selected states. See FB_PackMLStateModel_ST code for further details.*)
(*Calling & Updating the state model*)
(*TODO: Evaluate and change all input conditions according your application needs*)
fbStateModel(
	bResetFB:= ,
	eModeReq:= HMI_uModeReq,
	wIgnoreState := 2#000000,		(*TODO: Which states should be ignodered. Default: 2#000000 or 2#100000. The latter is ignoring Resetting state*)
	bSC:= ,			(*Must not be assigned ANY variable, because fb input is directly operated!!!*)
	bAbort:= NOT (IEmergencyClear  OR  IPressureApplied),
	bClear:= IEmergencyClear,
	bReset:= I_Btn_Start,
	bStart:= I_Btn_Start,
	bHold:= ,
	bUn_Hold:= ,
	bSuspend:= ,
	bUn_Suspend:= ,
	bStop:= I_Btn_Stop ,
	bComplete:= ,
	bAck_Completed:= ,
	eMode=> PLC_uModeCurrent,
	eState=> PLC_uStateCurrent);

(* ****** Section 6: Here we update all outputs according the current state of our PackML model. This allows us to process the in single location.
The control of outputs is bind to state, not e.g. to inputs. The inputs are the one driving the PackML model forward. Again CASE structure can be used.*)
(*Call for HMI and UI update*)
(*PRG_Drive_Link()*);
HMI_and_UI_Update;
END_PROGRAM
ACTION	actAborting:
bDriveEnabled := FALSE;
PRG_Sorting(bReset:=TRUE , bExecute:= FALSE);
END_ACTION

ACTION	HMI_and_UI_Update:
(*Simulate emergency stop circuitry*)
rsEmergencyClear(
	SET:= I_Btn_Reset,
	RESET1:= I_Btn_EStop ,
	Q1=> IEmergencyClear);

(*HMI Update*)
PRG_Blinking (bSign4Hz=> , bSign2Hz=> , bSign1Hz=> , bSign0_5Hz=> );
(*Init values*)
O_Light_BeaconRed := FALSE;

(*OLight_Start :=  (fbStateModel.eState >= eSt_Resetting) AND (fbStateModel.eState < eSt_Completed);*)
CASE fbStateModel.eState OF
eSt_Aborting, eSt_Aborted:
	O_Light_BeaconRed := PRG_Blinking.bSign1Hz;
eSt_Clearing:
	O_Light_BeaconRed := PRG_Blinking.bSign0_5Hz;
eSt_Stopped, eSt_Completed:
	O_Light_BeaconRed := TRUE;
eSt_Starting:
	;
END_CASE;
END_ACTION



